#!/usr/bin/env ruby

require "slack-ruby-client"
require "thor"
require "open3"

class WorkDay < Thor
  include Thor::Actions

  package_name "WorkDay"

  def self.source_root
    File.expand_path(__dir__)
  end

  desc "start", "Start up your PCO workday"
  option(:skip_slack, type: :boolean, aliases: :s, desc: "Whether to send a message to Slack or not. Default is to send a message.")
  option(:skip_update_box, type: :boolean, aliases: :b, desc: "Whether to update pco-box or not. Default is to update.")
  option(:skip_update_apps, type: :boolean, aliases: :a, desc: "Whether to update apps or not. Default is to update.")
  option(:run_webpack, type: :boolean, aliases: :w, desc: "Whether to run webpack when updating apps or not. Default is to skip it.")
  def start
    prompt_for_slack_messaage unless options[:skip_slack]
    update_pco_box unless options[:skip_update_box]
    update_apps(options[:run_webpack]) unless options[:skip_update_apps]
  end

  desc "end", "End your PCO workday"
  def end
  end

  private

  def home
    @home ||= ENV.fetch("HOME")
  end

  def prompt_for_slack_message
    slack_msg_type = ask("What kind of Slack message shall we send?", limited_to: %w[standup normal])
    slack_msg = slack_msg_type == "standup" ? prompt_for_standup_msg : prompt_for_normal_msg
    say <<~SLACK
      Sending to Slack:
      #{slack_msg}
    SLACK
    send_to_slack(slack_msg)
  end

  def prompt_for_standup_msg
    @yesterday = ask "What happened yesterday? What went well? What didn’t?"
    @today = ask "What are you planning to work on today? Any blockers?"
    @other = ask "Anything else the team should know?"
    template_string("slack_standup.erb")
  end

  def prompt_for_normal_msg
    ask "What would you like to say?"
  end

  def send_to_slack(msg)
    slack = Slack::Web::Client.new(token: ENV.fetch("SLACK_API_TOKEN"))
    slack.auth_test
    slack.chat_postMessage(
      channel: "@bweave",
      text: msg,
      as_user: true,
      icon_url: "https://ca.slack-edge.com/T024L9M0Y-U5767U2TX-9007e0365f04-72",
    )
  end

  def update_pco_box
    say "⚙️  Updating pco-box", :green
    Dir.chdir("#{home}/pco-box") do
      run_command("git", "pull")
      run_command("box", "update")
    end
  end

  def update_apps(run_webpack)
    say "⚙️  Updating apps", :green
    args = %w[box update-apps --auto-master]
    args << "--skip-webpack" unless run_webpack
    run_command(*args)
  end

  def run_command(*args)
    # https://nickcharlton.net/posts/ruby-subprocesses-with-stdout-stderr-streams.html
    Open3.popen3({"NON_INTERACTIVE" => "true"}, *args) do |stdin, stdout, stderr, status_thread|
      {out: stdout, err: stderr}.each do |key, stream|
        Thread.new do
          until (line = stream.gets).nil?
            puts "#{key}: #{line}"
          end
        end
      end

      status_thread.join
    end
  end

  # A version of Thor's template that returns the rendered string instead of creating a new file.
  # Copied from https://github.com/erikhuda/thor/blob/011dc48b5ea92767445b062f971664235973c8b4/lib/thor/actions/file_manipulation.rb#L115
  def template_string(source, *args, &block)
    config = args.last.is_a?(Hash) ? args.pop : {}

    source = File.expand_path(find_in_source_paths(source.to_s))
    context = config.delete(:context) || instance_eval("binding") # rubocop: disable Style/EvalWithLocation

    # Assume Ruby 2.6+
    capturable_erb = CapturableERB.new(::File.binread(source), trim_mode: "-", eoutvar: "@output_buffer")
    content = capturable_erb.tap do |erb|
      erb.filename = source
    end.result(context)
    content = yield(content) if block
    content
  end
end

WorkDay.start(ARGV)
